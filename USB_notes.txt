There are 4 layers:

▄█░ ░ 　 ▒█▀▀█ █░░█ █░░█ █▀▀ ░▀░ █▀▀ █▀▀█ █░░ 　 █░░ █▀▀█ █░░█ █▀▀ █▀▀█ 
░█░ ▄ 　 ▒█▄▄█ █▀▀█ █▄▄█ ▀▀█ ▀█▀ █░░ █▄▄█ █░░ 　 █░░ █▄▄█ █▄▄█ █▀▀ █▄▄▀ 
▄█▄ █ 　 ▒█░░░ ▀░░▀ ▄▄▄█ ▀▀▀ ▀▀▀ ▀▀▀ ▀░░▀ ▀▀▀ 　 ▀▀▀ ▀░░▀ ▄▄▄█ ▀▀▀ ▀░▀▀

Bit timings, pull-ups, differential DP/DM signalling.
TinyUSB and the MCU peripheral handle all of this. You won’t touch it.


▀█ ░   █░█ █▀ █▄▄   █▀█ █▀█ █▀█ ▀█▀ █▀█ █▀▀ █▀█ █░░   █░░ ▄▀█ █▄█ █▀▀ █▀█
█▄ ▄   █▄█ ▄█ █▄█   █▀▀ █▀▄ █▄█ ░█░ █▄█ █▄▄ █▄█ █▄▄   █▄▄ █▀█ ░█░ ██▄ █▀▄

This is where packets live. USB packets are LEGO bricks:
USB has only three packet types:

1.Token packets

  -IN
  -OUT
  -SETUP
  -(also SOF, PING, etc)
    They say “host wants to read/write from endpoint X”.

2.Data packets
  -DATA0
  -DATA1
  -(DATA2, MDATA for high-speed)
   Contain your bytes.

3.Handshake packets
  -ACK
  -NAK
  -STALL  (And a few others)



██████╗░
╚════██╗
░█████╔╝
░╚═══██╗
██████╔╝
╚═════╝░
░   █░█ █▀ █▄▄   ▀█▀ █▀█ ▄▀█ █▄░█ █▀ ▄▀█ █▀▀ ▀█▀ █ █▀█ █▄░█ █▀
▄   █▄█ ▄█ █▄█   ░█░ █▀▄ █▀█ █░▀█ ▄█ █▀█ █▄▄ ░█░ █ █▄█ █░▀█ ▄█

A transaction is usually:

  -Host sends Token
  -Then Data
  -Device answers with ACK

Or the opposite for an IN transfer.

This is like the “function call” layer.


█░█ ░   █░█ █▀ █▄▄   ▀█▀ █▀█ ▄▀█ █▄░█ █▀ █▀▀ █▀▀ █▀█ █▀   ▄▀ █░█ █ █▀▀ █░█ ▄▄ █░░ █▀▀ █░█ █▀▀ █░░   ▄▀█ █▀█ █ ▀▄
▀▀█ ▄   █▄█ ▄█ █▄█   ░█░ █▀▄ █▀█ █░▀█ ▄█ █▀░ ██▄ █▀▄ ▄█   ▀▄ █▀█ █ █▄█ █▀█ ░░ █▄▄ ██▄ ▀▄▀ ██▄ █▄▄   █▀█ █▀▀ █ ▄▀

This is where endpoints make sense:

-Control transfer (mandatory EP0)
-Interrupt transfer (HID, CDC notifications)
-Bulk transfer (CDC-ACM data, MSC, etc)
-Isochronous (audio/video, time-critical)

This is the layer TinyUSB really works at.

The REAL "USB application layer": Classes

This is what TinyUSB exposes:
-CDC: virtual COM port
-HID: keyboard, mouse, custom HID
-MSC: USB flash drive
-DFU: firmware updates
-Audio
-MIDI

Think of classes like “protocol profiles”.
Exactly like TCP → HTTP/FTP/SSH.
