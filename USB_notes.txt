There are 4 layers:

▄█░ ░ 　 ▒█▀▀█ █░░█ █░░█ █▀▀ ░▀░ █▀▀ █▀▀█ █░░ 　 █░░ █▀▀█ █░░█ █▀▀ █▀▀█ 
░█░ ▄ 　 ▒█▄▄█ █▀▀█ █▄▄█ ▀▀█ ▀█▀ █░░ █▄▄█ █░░ 　 █░░ █▄▄█ █▄▄█ █▀▀ █▄▄▀ 
▄█▄ █ 　 ▒█░░░ ▀░░▀ ▄▄▄█ ▀▀▀ ▀▀▀ ▀▀▀ ▀░░▀ ▀▀▀ 　 ▀▀▀ ▀░░▀ ▄▄▄█ ▀▀▀ ▀░▀▀


A full-speed device stays in Idle J state until host starts polling.
Definitions for full-speed:

-J state: D+ = HIGH, D– = LOW
-K state: D+ = LOW, D– = HIGH

NRZI encoding:

Logical 1: maintain previous state
Logical 0: toggle between J/K

Bit timings, pull-ups, differential DP/DM signalling.
TinyUSB and the MCU peripheral handle all of this. You won’t touch it.

-Logical J and K states are encoded as combinations of D+ and D–
-Idle is a J state
-Data bits are encoded as transitions between J and K (NRZI)

The absolute voltage doesn't matter much; the receiver listens for the difference between D+ and D–.

HOST ALWAYS STARTS: No device-to-host communication until host sends packets

USB is strictly host driven.
The device does NOT send anything unless the host explicitly asks.


▀█ ░   █░█ █▀ █▄▄   █▀█ █▀█ █▀█ ▀█▀ █▀█ █▀▀ █▀█ █░░   █░░ ▄▀█ █▄█ █▀▀ █▀█
█▄ ▄   █▄█ ▄█ █▄█   █▀▀ █▀▄ █▄█ ░█░ █▄█ █▄▄ █▄█ █▄▄   █▄▄ █▀█ ░█░ ██▄ █▀▄

This is where packets live. USB packets are LEGO bricks:
USB has only three packet types:

1.Token packets

  -IN
  -OUT
  -SETUP
  -(also SOF, PING, etc)
    They say “host wants to read/write from endpoint X”.

2.Data packets
  -DATA0
  -DATA1
  -(DATA2, MDATA for high-speed)
   Contain your bytes.

3.Handshake packets
  -ACK
  -NAK
  -STALL  (And a few others)



██████╗░
╚════██╗
░█████╔╝
░╚═══██╗
██████╔╝
╚═════╝░
░   █░█ █▀ █▄▄   ▀█▀ █▀█ ▄▀█ █▄░█ █▀ ▄▀█ █▀▀ ▀█▀ █ █▀█ █▄░█ █▀
▄   █▄█ ▄█ █▄█   ░█░ █▀▄ █▀█ █░▀█ ▄█ █▀█ █▄▄ ░█░ █ █▄█ █░▀█ ▄█

A transaction is usually:

  -Host sends Token
  -Then Data
  -Device answers with ACK

Or the opposite for an IN transfer.

This is like the “function call” layer.


█░█ ░   █░█ █▀ █▄▄   ▀█▀ █▀█ ▄▀█ █▄░█ █▀ █▀▀ █▀▀ █▀█ █▀   ▄▀ █░█ █ █▀▀ █░█ ▄▄ █░░ █▀▀ █░█ █▀▀ █░░   ▄▀█ █▀█ █ ▀▄
▀▀█ ▄   █▄█ ▄█ █▄█   ░█░ █▀▄ █▀█ █░▀█ ▄█ █▀░ ██▄ █▀▄ ▄█   ▀▄ █▀█ █ █▄█ █▀█ ░░ █▄▄ ██▄ ▀▄▀ ██▄ █▄▄   █▀█ █▀▀ █ ▄▀

This is where endpoints make sense:

-Control transfer (mandatory EP0)
-Interrupt transfer (HID, CDC notifications)
-Bulk transfer (CDC-ACM data, MSC, etc)
-Isochronous (audio/video, time-critical)

This is the layer TinyUSB really works at.


▀█▀ █░█ █▀▀   █▀█ █▀▀ ▄▀█ █░░   █░█ █░█ █▀ █▄▄   ▄▀█ █▀█ █▀█ █░░ █ █▀▀ ▄▀█ ▀█▀ █ █▀█ █▄░█   █░░ ▄▀█ █▄█ █▀▀ █▀█ █░█ ▀
░█░ █▀█ ██▄   █▀▄ ██▄ █▀█ █▄▄   ░░░ █▄█ ▄█ █▄█   █▀█ █▀▀ █▀▀ █▄▄ █ █▄▄ █▀█ ░█░ █ █▄█ █░▀█   █▄▄ █▀█ ░█░ ██▄ █▀▄ ░░░ ▄

█▀▀ █░░ ▄▀█ █▀ █▀ █▀▀ █▀
█▄▄ █▄▄ █▀█ ▄█ ▄█ ██▄ ▄█

This is what TinyUSB exposes:
-CDC: virtual COM port
-HID: keyboard, mouse, custom HID
-MSC: USB flash drive
-DFU: firmware updates
-Audio
-MIDI

Think of classes like “protocol profiles”.
Exactly like TCP → HTTP/FTP/SSH.
